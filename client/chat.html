{% extends 'base.html' %}
{% block content %}
<!-- Adding Quill Styles and Emoji Plugin -->
<link rel="stylesheet" href="https://cdn.quilljs.com/1.3.6/quill.snow.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill-emoji/dist/quill-emoji.css">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/quill-emoji/dist/quill-emoji.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>

<div class="chat-container">
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>Welcome {{username}}!</h2>
            <button type="button" name="leave" id="leave-btn" onclick="leaveRoom()">
                Logout
            </button>
        </div>
        <div class="sidebar-userlist">
            <h3>Users</h3>
            <form id="chat-selection">
                <div id="user-list"></div>
                <button type="button" id="chat-select-btn" onclick="createChat()">Start Chat</button>
            </form>
        </div>
        <div class="sidebar-activechats">
            <h3>Active Chats</h3>
            <div id="active-chats"></div>
        </div>
    </div>

    <div class="chat-box">
        <h3 id="chat-header">General Chat Room</h3>
        <p id="dm-info" style="display: none; font-size: 15px; font-style: italic; color: #e91414; margin: 5px 0;">
            This chat window is end-to-end encrypted.
        </p>
        <div class="messages" id="messages"></div>
        <div id="typing-indicator"></div>

        <div class="input-text">
            <!-- Quill Editor -->
            <div id="editor-container"></div>
            <!-- File Upload & Download Buttons -->
            <div class="file-controls">
                <span class="file-label">Upload File</span>
                <input type="file" id="file-input" style="display: none;" onchange="uploadFile()" />
                <button id="upload-btn" onclick="document.getElementById('file-input').click();" title="Upload File">‚¨ÜÔ∏è</button>

                <span class="file-label">Download File</span>
                <button id="download-btn" onclick="downloadFile()" title="Download File">‚¨áÔ∏è</button>
                <span id="upload-status"></span>

            </div>
            <div id="file-selection-modal" style="display: none;">
                <label for="file-select">Select file to download:</label>
                <select id="file-select"></select>
                <button onclick="confirmDownload()">Download</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
            <button type="button" id="send-btn" onclick="sendMessage()">Send</button>
        </div>
    </div>
</div>

<script>
    // Your web app's Firebase configuration
    const firebaseConfig = {
    apiKey: "AIzaSyASJv5LZ-8UIO4FNV4D0xx1b-Ddava_0IQ",
    authDomain: "chat-c41b6.firebaseapp.com",
    projectId: "chat-c41b6",
    storageBucket: "chat-c41b6.firebasestorage.app",
    messagingSenderId: "995826399250",
    appId: "1:995826399250:web:fe01aa746765aff92940cb"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const storage = firebase.storage();
</script>

<script type="text/javascript">
    //for chat room
    let ws;
    let username = "{{ username }}";
    let currentChatId = "general_chat";
    let activeChats = new Set(); 
    let typingTimeout;
    let typingAnimationInterval;


    // secure file sharing variables & e2e keys
    let groupKeys = {}; 
    let availableFiles = []; 
    let userKeyPair; 
    let recipientPublicKeys = {};


    async function generateGroupKey() {
        return await crypto.subtle.generateKey(
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt"]
        );
    }

    async function exportAndEncryptGroupKey(groupKey, recipientPubKey, myPrivateKey) {
        const rawKey = await crypto.subtle.exportKey("raw", groupKey);
        const symmetricKey = await deriveSymmetricKey(myPrivateKey, recipientPubKey);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, symmetricKey, rawKey);
        return {
            groupKey: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
            groupKeyiv: btoa(String.fromCharCode(...iv))
        };
    }

    //genereates ECDH key pair for users
    async function generateKeyPair() {
        return await crypto.subtle.generateKey(
            { name: "ECDH", namedCurve: "P-256" },
            true,
            ["deriveKey"]
        );
    }

    async function generateOrLoadKeyPair() {
        const storedPrivate = sessionStorage.getItem("ecdh_private");
        const storedPublic = sessionStorage.getItem("ecdh_public");

        if (storedPrivate && storedPublic) {
            // Restore key pair
            const privateKey = await crypto.subtle.importKey(
                "jwk",
                JSON.parse(storedPrivate),
                { name: "ECDH", namedCurve: "P-256" },
                true,
                ["deriveKey"]
            );

            const publicKey = await crypto.subtle.importKey(
                "jwk",
                JSON.parse(storedPublic),
                { name: "ECDH", namedCurve: "P-256" },
                true,
                []
            );

            console.log("ECDH key pair loaded from sessionStorage");
            return { publicKey, privateKey };
        } else {
            // Generate and store key pair
            const keyPair = await generateKeyPair();
            const exportedPrivate = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
            const exportedPublic = await crypto.subtle.exportKey("jwk", keyPair.publicKey);

            sessionStorage.setItem("ecdh_private", JSON.stringify(exportedPrivate));
            sessionStorage.setItem("ecdh_public", JSON.stringify(exportedPublic));

            console.log("New ECDH key pair generated and stored");
            return keyPair;
        }
    }


    async function deriveSymmetricKey(privateKey, recipientPublicKey) {
        return await crypto.subtle.deriveKey(
            { name: "ECDH", public: recipientPublicKey },
            privateKey,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"]
        );
    }


    async function encryptChatMessage(message, symmetricKey) {
    // Uses 12 bit IV for AES-GCM 
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encodedMessage = new TextEncoder().encode(message);
        const encryptedBuffer = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            symmetricKey,
            encodedMessage
        );
        // Return the ciphertext and IV 
        return { ciphertext: new Uint8Array(encryptedBuffer), iv };
    }

    async function decryptChatMessage(ciphertextBase64, ivBase64, symmetricKey) {
        const ciphertext = Uint8Array.from(atob(ciphertextBase64), c => c.charCodeAt(0));
        const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
        const decryptedBuffer = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv },
            symmetricKey,
            ciphertext
        );
        return new TextDecoder().decode(decryptedBuffer);
    }

    async function loadHistory(chatId) {
    console.log('loading history for', chatId);
      const resp = await fetch(`/api/history/${chatId}`);
      if (!resp.ok) {
        console.error("Could not load history for", chatId, resp.status);
        return;
      }
      const msgs = await resp.json();
      console.log('got history:', msgs);
      msgs.forEach(m => showMessage(m.timestamp, m.sender, m.content));
    }

    async function logMessageToDb(chatId, action, details) {
      await fetch(`/api/logs/${chatId}`, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({ action, details })
      });
    }
    
    function connectWebSocket() {
        const scheme = window.location.protocol === "https:" ? "wss" : "ws";
        ws = new WebSocket(`${scheme}://${window.location.host}/ws`);


        ws.onopen = () => {
            console.log("WebSocket Connection open from client. Sending username :",username)
            // ws.send(username);  //Sending username first for identification
            ws.send(JSON.stringify({ "username": username }));
        }

        ws.onmessage = async (event) => {
            console.log("Received message from WS Server. message:", event.data);
            let data = JSON.parse(event.data);

            // Process chat messages if present (encrypted or unencrypted)
            if (data.chat_id) {
                if (!activeChats.has(data.chat_id)) {
                    activeChats.add(data.chat_id);
                    updateActiveChats();
                }

                // Handle the encrypted group key if it's sent
                if (data.group_key && !groupKeys[data.chat_id]) {
                    try {
                        const encryptedKeyBytes = Uint8Array.from(atob(data.group_key), c => c.charCodeAt(0));
                        const ivBytes = Uint8Array.from(atob(data.group_key_iv), c => c.charCodeAt(0));

                        // Derive symmetric key using your ECDH private key and sender's public key
                        if (!recipientPublicKeys[data.sender]) {
                            let res = await fetch(`/get_public_key/${data.sender}`);
                            let pkData = await res.json();
                            if (pkData.public_key) {
                                let importedKey = await crypto.subtle.importKey(
                                    "jwk",
                                    JSON.parse(pkData.public_key),
                                    { name: "ECDH", namedCurve: "P-256" },
                                    true,
                                    [] 
                                );
                                recipientPublicKeys[data.sender] = importedKey;
                            } else {
                                console.error("Recipient public key not found for", data.sender);
                                return;
                            }
                        }
                        const senderPubKey = recipientPublicKeys[data.sender];
                        const symmetricKey = await deriveSymmetricKey(userKeyPair.privateKey, senderPubKey);

                        const decryptedKeyBuffer = await crypto.subtle.decrypt(
                            { name: "AES-GCM", iv: ivBytes },
                            symmetricKey,
                            encryptedKeyBytes
                        );

                        const groupSymmetricKey = await crypto.subtle.importKey(
                            "raw",
                            decryptedKeyBuffer,
                            { name: "AES-GCM", length: 256 },
                            false,
                            ["encrypt", "decrypt"]
                        );

                        groupKeys[data.chat_id] = groupSymmetricKey;
                        console.log("Group key imported and cached for", data.chat_id);
                    } catch (err) {
                        console.error("Error decrypting group key:", err);
                        return;
                    }
                }

                // Show typing indicator in active chat
                if (data.type === "typing") {
                    if (data.chat_id === currentChatId) {
                        showTypingIndicator(data.sender, data.isTyping);
                    }
                }

                // Process file upload responses
                else if (data.type === "file_upload_response") {
                    if (data.chat_id !== currentChatId) 
                        return;  //Ignore files from other chats

                    console.log("File uploaded successfully:", data.filename);
                    if (!availableFiles.includes(data.filename)) {
                        availableFiles.push(data.filename);
                        updateFileDropdown();
                    }
                    showMessage(data.timestamp, data.sender, "Uploaded file: " + data.filename);
                }

                // Only display the message if it belongs to the currently active chat window
                else if (data.chat_id === currentChatId) {
                    if (data.encrypted && !data.chat_id.startsWith("group_")) {
                        // DM message decryption branch
                        let participants = data.chat_id.split("_");
                        let recipient = participants.find(u => u !== username);
                        if (!recipient) {
                            console.error("Recipient not found in chat_id");
                            return;
                        }
                        if (!recipientPublicKeys[recipient]) {
                            let res = await fetch(`/get_public_key/${recipient}`);
                            let pkData = await res.json();
                            if (pkData.public_key) {
                                let importedKey = await crypto.subtle.importKey(
                                    "jwk",
                                    JSON.parse(pkData.public_key),
                                    { name: "ECDH", namedCurve: "P-256" },
                                    true,
                                    [] 
                                );
                                recipientPublicKeys[recipient] = importedKey;
                            } else {
                                console.error("Recipient public key not found for", recipient);
                                return;
                            }
                        }
                        let conversationKey = await deriveSymmetricKey(userKeyPair.privateKey, recipientPublicKeys[recipient]);
                        let plaintext = await decryptChatMessage(data.message, data.iv, conversationKey);
                        showMessage(data.timestamp, data.sender, plaintext);
                    } else if (data.encrypted && data.chat_id.startsWith("group_")) {
                        // Group message decryption branch
                        // Use the cached group key to decrypt the message
                        const groupKey = groupKeys[data.chat_id];
                        if (!groupKey) {
                            console.error("Missing group key for", data.chat_id);
                            return;
                        }

                        try {
                            const plaintext = await decryptChatMessage(data.message, data.iv, groupKey);
                            showMessage(data.timestamp, data.sender, plaintext);
                        } catch (err) {
                            console.error("Failed to decrypt group message:", err);
                        }
                    } else {
                        // For general and group chats, display the plain text message.
                        showMessage(data.timestamp, data.sender, data.message);
                    }
                }
            }
            // Process file download responses
            else if (data.type === "file_download_response") {
                console.log("File downloaded. Decrypting...");
                console.log("Received firebaseurl & base64 iv:", data.iv);
                
                downloadFileFromFirebase(data.firebase_url, data.filename,data.iv)
            }
            // Process user list status updates
            else if (data.type === "user_list_status_update") {
                updateUserList(data.users);
            }
            // Process errors
            else if (data.error) {
                showMessage(data.timestamp, "SERVER", data.error);
            }
        };



        window.addEventListener("beforeunload", () => {
            ws.close();  // Explicitly close WebSocket when the user closes tab
        });
        
        ws.onclose = (event) => {
            console.log("WebSocket closed.");

            // Prevents reconnection loops and tracks the number of reconnection attempts
            let maxRetries = 5;
            let retryCount = 0;

            // Attempt to reconnect if it was an unexpected disconnection
            if (!event.wasClean && retryCount < maxRetries) {
                console.log("Reconnecting...");
                setTimeout(() => {
                    connectWebSocket();
                    retryCount++;
                }, 3000); // Auto-reconnect after 3 seconds if connection is lost
            } else if (retryCount >= maxRetries) {
                console.warn("Max reconnection attempts reached. Please refresh the page.");
            }
        };

        ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            ws.close();
        };
    }

    // when the window lodas, it loads file sharing keys and E2E keys
    window.onload = async () => {
        try {

            //for E2E chat, a public key registar
            // userKeyPair = await generateKeyPair();
            userKeyPair = await generateOrLoadKeyPair();

            if (!sessionStorage.getItem("public_key_registered")) {
                let exportedPublic = await crypto.subtle.exportKey("jwk", userKeyPair.publicKey);
                await fetch("/register_public_key", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ username: username, public_key: JSON.stringify(exportedPublic) })
                });
                console.log("User ECDH key pair generated and public key registered.");
                sessionStorage.setItem("public_key_registered", "true");
            }

        } catch (error) {
            console.error(" Error registering public Key:", error);
        }   

        getFirebaseTokenAndLogin();
        connectWebSocket();  

        await loadHistory(currentChatId);
    };

    async function getFirebaseTokenAndLogin() {
        const res = await fetch("/get_firebase_token", {
            method: "GET",
            headers: { "Content-Type": "application/json" }
        });

        const data = await res.json();
        if (!data.firebase_token) {
            alert("Failed to get Firebase token");
            return;
        }

        // Firebase JS SDK login
        await firebase.auth().signInWithCustomToken(data.firebase_token);
        console.log("Firebase login successful");
    }


    // encrypting file before upload
    async function encryptFile(file) {
        console.log("encryptFile called for file:", file.name);

        const chatId = currentChatId;
        let iv = null;
        let key = null;
        let arrayBuffer = await file.arrayBuffer();

        // General chat upload file as it is
        if (chatId=="general_chat") {
            console.log("General chat: uploading file.");
            return { encryptedFile: new Uint8Array(arrayBuffer), iv: null };  // No IV needed
        } else if (chatId.startsWith("group_")) { // get group key
            key = groupKeys[chatId];
            if (!key ) {
                console.error("No Group decryption key available!");
                return null;
            }
        } else { //private chat, check for recipient public key
            let participants = chatId.split("_");
            let recipient = participants.find(u => u !== username);
            if (!recipient) {
                console.error("Recipient not found in chat_id");
                return null;
            }
            if (!recipientPublicKeys[recipient]) {
                let res = await fetch(`/get_public_key/${recipient}`);
                let pkData = await res.json();
                if (pkData.public_key) {
                    let importedKey = await crypto.subtle.importKey(
                        "jwk",
                        JSON.parse(pkData.public_key),
                        { name: "ECDH", namedCurve: "P-256" },
                        true,
                        []
                    );
                    recipientPublicKeys[recipient] = importedKey;
                } else {
                    console.error("Recipient public key not found for", recipient);
                    return null;
                }
            }
            key = await deriveSymmetricKey(userKeyPair.privateKey, recipientPublicKeys[recipient]);
        }
        
        if (!key) {
            console.error("No encryption key available for chat: ", chatId);
            return null;
        }

        iv = crypto.getRandomValues(new Uint8Array(16));

        try {
            let encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                arrayBuffer
            );
            let encryptedArray = new Uint8Array(encryptedData); 
            return { encryptedFile: encryptedArray, iv: iv};
        } catch (error) {
            console.error("Error during file encryption:", error);
            return null;
        }

    }

    async function decryptFile(filename, encryptedData, ivBase64) {
        const chatId = currentChatId;
        let key = null;
        let iv = null;

        try {
            console.log("Decrypting file:", filename);

            // General chat upload file as it is
            if (chatId=="general_chat") {
                console.log("General chat: downloading file.");
                let fileBytes = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                let blob = new Blob([fileBytes]);
                let link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                return;
            } else if (chatId.startsWith("group_")) { // get group key
                key = groupKeys[chatId];
                if (!key ) {
                    console.error("No Group decryption key available!");
                    return null;
                }
            } else { //private chat, check for recipient public key
                let participants = chatId.split("_");
                let recipient = participants.find(u => u !== username);
                if (!recipient) {
                    console.error("Recipient not found in chat_id");
                    return;
                }
                if (!recipientPublicKeys[recipient]) {
                    let res = await fetch(`/get_public_key/${recipient}`);
                    let pkData = await res.json();
                    if (pkData.public_key) {
                        let importedKey = await crypto.subtle.importKey(
                            "jwk",
                            JSON.parse(pkData.public_key),
                            { name: "ECDH", namedCurve: "P-256" },
                            true,
                            []
                        );
                        recipientPublicKeys[recipient] = importedKey;
                    } else {
                        console.error("Recipient public key not found for", recipient);
                        return;
                    }
                }
                key = await deriveSymmetricKey(userKeyPair.privateKey, recipientPublicKeys[recipient]);
            }
            
            if (!key) {
                console.error("No encryption key available for chat: ", chatId);
                return null;
            }

            //Decoding base64 data & IV
            let encryptedBytes = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
            iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
        
            //Decrypt using group decryption key and provided IV
            let decryptedBuffer = await crypto.subtle.decrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                },
                key,
                encryptedBytes
            );

            console.log("File decrypted successfully.");

            
            let blob = new Blob([decryptedBuffer], { type: "text/plain;charset=utf-8" });
            let link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();

        } catch (error) {
            console.error("Error decrypting file:", error);
            alert("Failed to decrypt file.");
        }
    }

    // Update the dropdown options based on availableFiles array
    function updateFileDropdown() {
        const fileSelect = document.getElementById("file-select");
        fileSelect.innerHTML = availableFiles
            .map(file => `<option value="${file}">${file}</option>`)
            .join("");
    }

     // Upload File via WebSocket after malware scan
    async function uploadFile() {
        let fileInput = document.getElementById("file-input");
        const status = document.getElementById("upload-status");

        // Clear any previous status immediately
        status.textContent = "";
        status.style.color = "#000";  // Default color

        if (!fileInput.files.length) {
            alert("Please select a file to upload.");
            return;
        }

        let file = fileInput.files[0];
        console.log(" Selected file for upload:", file.name);
        fileInput.value = ""; // Clear previous selection
        
        let formData = new FormData();
        formData.append("file", file);

        let analysisId;
        //Step 1: Send file to VirusTotal via server API
        try {
            status.textContent = "üîç Scanning file for malware...";
            alert("Please wait atleast 20 seconds for file scan & upload!");
            const scanRes = await fetch("/scan", {
                method: "POST",
                body: formData,
            });

            if (!scanRes.ok) {
                const errText = await scanRes.text();
                throw new Error(`Scan request failed: ${errText}`);
            }

            const data = await scanRes.json();
            analysisId = data.analysis_id;
            console.log("VirusTotal analysis ID:", analysisId);
        } catch (err) {
            console.error("Error uploading file for scan:", err);
            setTimeout(() => status.textContent = "", 5000);
            alert("VirusTotal scan failed.");
            return;
        }

        //Step 2: Poll for scan result
        try {
            const result = await pollScanResult(analysisId);
            const malicious = result.stats.malicious || 0;

            if (malicious > 0) {
                alert("The uploaded file is flagged as malicious and will not be sent.");
                return;
            }
            console.log("File is clean. Proceeding with encryption and upload...");
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert("WebSocket is not connected. Try reloading the page.");
                return;
            }

            status.textContent = "üîê Encrypting file...";
            console.log("About to encrypt file:", file.name);

            let { encryptedFile, iv } = await encryptFile(file);

            // Encode encrypted file to Base64
            let ivBase64 = iv ? btoa(String.fromCharCode(...new Uint8Array(iv))) : null;


            status.textContent = "üì§ Uploading file to Firebase...";
            // Upload encrpted file to Firebase and get the URL
            const firebaseURL = await uploadFileToFirebase(file.name, encryptedFile);

            if (!firebaseURL) {
                // If upload failed, do not proceed with saving metadata
                console.error("File upload failed, no URL returned.");
                setTimeout(() => status.textContent = "", 5000);
                return;
            }
            // Notify the server with file metadata only
            ws.send(JSON.stringify({
                type: "file_upload",
                filename: file.name,
                firebase_url: firebaseURL,
                iv: ivBase64,
                username: username,
                chat_id: currentChatId
            }));

            console.log("File sent for upload:", file.name);
            status.textContent = "‚úÖ File uploaded successfully.";
            setTimeout(() => status.textContent = "", 5000);
        } catch (error) {
            console.error("Error polling VirusTotal scan:", error);
            setTimeout(() => status.textContent = "", 5000);
            alert("Scan did not complete successfully.");
        }
    }

    async function pollScanResult(analysisId, maxAttempts = 25, interval = 3000) {
        let attempts = 0;

        while (attempts < maxAttempts) {
            const res = await fetch(`/scan-result/${analysisId}`);
            if (!res.ok) {
                throw new Error("Error checking scan status");
            }

            const data = await res.json();
            console.log("Scan status:", data.status);

            if (data.status === "completed") {
                return data;
            }

            await new Promise(resolve => setTimeout(resolve, interval));
            attempts++;
        }

        throw new Error("VirusTotal analysis timed out");
    }

    async function uploadFileToFirebase(filename, encryptedBuffer) {
        try {
            const storageRef = storage.ref(`chat_files/${currentChatId}/${filename}`);
            const blob = new Blob([encryptedBuffer]);
            const snapshot = await storageRef.put(blob);
            const downloadURL = await snapshot.ref.getDownloadURL();

            if (!downloadURL) {
                console.error("Failed to retrieve download URL.");
                alert("File upload failed: No URL returned.");
                return null;  // Indicate failure
            }    
            console.log("File uploaded to Firebase");
            return downloadURL;
        } catch (error) {
            console.error("Upload failed:", error);
            alert("File upload failed! Please try again.");
            return null;  // Indicate failure
        }
    }

    async function downloadFileFromFirebase(downloadURL, fileName, base64iv) {
        try {
            const encryptedFileRes  = await fetch(downloadURL);
            const encryptedArrayBuffer = await encryptedFileRes.arrayBuffer();
            // Convert ArrayBuffer to base64 string
            const uint8Array = new Uint8Array(encryptedArrayBuffer);
            const base64EncryptedData = btoa(String.fromCharCode(...uint8Array));

            await decryptFile(fileName, base64EncryptedData, base64iv);

        } catch (err) {
            console.error("Failed to download from Firebase:", err);
            alert("File Download failed!");
        }
    }

    function downloadFile() {
            if (availableFiles.length === 0) {
                alert("No files available for download.");
                return;
            }
        document.getElementById("file-selection-modal").style.display = "block";     
    }


    function confirmDownload() {
        const fileSelect = document.getElementById("file-select");
        const selectedFile = fileSelect.value;
        if (selectedFile) {
            ws.send(JSON.stringify({ type: "file_download", filename: selectedFile, username: username, chat_id: currentChatId }));
            console.log("Download request sent for:", selectedFile);
        }
        closeModal();
    }


    function closeModal() {
        document.getElementById("file-selection-modal").style.display = "none";
    }



    //Displaying connected clients available for chat with online/offline status
    function updateUserList(users) {

        let userListDiv = document.getElementById("user-list");
        userListDiv.innerHTML = "";

        users.forEach(userObj => {
            if (userObj.username !== username) {
                const label = document.createElement("label");
                label.className = "checkbox-label";

                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.value = userObj.username;
                checkbox.disabled = (userObj.status !== "online");

                const statusDot = document.createElement("span");
                statusDot.className = "status-dot " + (userObj.status === "online" ? "online" : "offline");

                label.appendChild(checkbox);
                label.appendChild(statusDot);
                label.appendChild(document.createTextNode(" " + userObj.username));
                userListDiv.appendChild(label);
            }
        });
    }

    //Creating chat based on checklist items selected
    async function createChat() {
        let selectedUsers = Array.from(document.querySelectorAll("#user-list input:checked"))
                                .map(input => input.value);

        if (selectedUsers.length === 0) 
            return alert("Select at least one user");

        if (selectedUsers.length === 1) {
            currentChatId = [username, selectedUsers[0]].sort().join("_");
            activeChats.add(currentChatId);
            loadChat(currentChatId);
        } else {
            let groupName = prompt("Enter group name:");
            if (!groupName) return;
            
            const groupKey = await generateGroupKey();
        const groupKeyExports = {};

        const members = [username, ...selectedUsers];
        for (const member of members) {
            if (!recipientPublicKeys[member]) {
                const res = await fetch(`/get_public_key/${member}`);
                const data = await res.json();
                if (!data.public_key) {
                    alert(`Missing public key for ${member}`);
                    return;
                }
                const imported = await crypto.subtle.importKey(
                    "jwk",
                    JSON.parse(data.public_key),
                    { name: "ECDH", namedCurve: "P-256" },
                    true,
                    []
                );
                recipientPublicKeys[member] = imported;
            }

            const encrypted = await exportAndEncryptGroupKey(
                groupKey,
                recipientPublicKeys[member],
                userKeyPair.privateKey
            );

            groupKeyExports[member] = encrypted;
        }

            fetch("/create_group", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ group_name: groupName, members, encrypted_keys: groupKeyExports})
            })
            .then(res => res.json())
            .then(data => {
                currentChatId = data.chat_id;
                activeChats.add(currentChatId);
                // Save the group key
                groupKeys[currentChatId] = groupKey;

                loadChat(currentChatId);
            });
        }
        updateActiveChats();
    }

    async function loadChat(chatId) {
        // Set the current chat ID and update the chat header.
        currentChatId = chatId;
        document.getElementById("chat-header").innerText = "Chat: " + chatId;
        const messagesDiv = document.getElementById("messages");
        messagesDiv.innerHTML = "";

        // pulls persisted rows from CockroachDB
        // await loadHistory(chatId);

        // Show or hide the DM E2E notice as appropriate:
        const dmInfo = document.getElementById("dm-info");
        if (chatId === "general_chat") {
            dmInfo.style.display = "none";
        } else {
            dmInfo.style.display = "block";
        }

        // Fetch the chat logs from the server.
        let response = await fetch(`/chat/${chatId}?t=${new Date().getTime()}`);
        let data = await response.json();
        console.log(`Chat logs fetched for ${chatId}:`, data.chat_logs);
        
        if (Array.isArray(data.files)) {
            availableFiles = data.files;

            if (availableFiles.length > 0) {
                updateFileDropdown();
            } else {
                availableFiles = [];  // Reset explicitly
                closeModal();
            }
        } else {
            availableFiles = [];  // Reset in case data.files is missing or not an array
            closeModal();
        }

        if (data.chat_logs) {
            //each log line in the persistent log to be in this format:
            // "Sender: logged_message - timestamp"
            // For DMs, logged_message is a JSON string: 
            for (let log of data.chat_logs) {
                // Using a regex that splits into three parts.
                let logParts = log.trim().match(/^(.*?): (.*?) - (.*)$/);
                if (logParts && logParts.length === 4) {
                    let sender = logParts[1].trim();
                    let loggedMessage = logParts[2].trim(); 
                    let timestamp = logParts[3].trim();
                    
                    // If it's a DM (direct message) then perform decryption.
                    if (chatId !== "general_chat" && !chatId.startsWith("group_")) {
                        try {
                            // Parse the logged message, which should be a JSON string.
                            let parsed = JSON.parse(loggedMessage);
                            
                            // Determine the recipient 
                            let participants = chatId.split("_");
                            let recipient = participants.find(u => u !== username);
                            if (!recipient) {
                                console.error("Recipient not found in chat_id:", chatId);
                                continue;
                            }
                            // Retrieve or import the recipient's public key.
                            if (!recipientPublicKeys[recipient]) {
                                let res = await fetch(`/get_public_key/${recipient}`);
                                let pkData = await res.json();
                                if (pkData.public_key) {
                                    let importedKey = await crypto.subtle.importKey(
                                        "jwk",
                                        JSON.parse(pkData.public_key),
                                        { name: "ECDH", namedCurve: "P-256" },
                                        true,
                                        []
                                    );
                                    recipientPublicKeys[recipient] = importedKey;
                                } else {
                                    console.error("Recipient public key not found for", recipient);
                                    continue;
                                }
                            }
                            // Derive the symmetric AES-GCM key
                            let conversationKey = await deriveSymmetricKey(userKeyPair.privateKey, recipientPublicKeys[recipient]);
                            // Decrypt the ciphertext using the derived key and the provided IV.
                            let plaintext = await decryptChatMessage(parsed.ciphertext, parsed.iv, conversationKey);
                            showMessage(timestamp, sender, plaintext);
                        } catch (e) {
                            console.error("Error decrypting DM log:", loggedMessage, e);
                            showMessage(timestamp, sender, "Decryption failed");
                        }
                    } else if(chatId.startsWith("group_")) {

                        // Parse the logged message, which should be a JSON string.
                        let parsed = JSON.parse(loggedMessage);

                        // Use the cached group key to decrypt the message
                        const groupKey = groupKeys[chatId];
                        if (!groupKey) {
                            console.log("Fetching missing group key for", chatId);
                            const res = await fetch(`/group_key/${chatId}`);
                            if (!res.ok) {
                                console.error("Failed to fetch group key:", await res.text());
                                return;
                            }

                            const { group_key, group_key_iv } = await res.json();

                            const encryptedKeyBytes = Uint8Array.from(atob(group_key), c => c.charCodeAt(0));
                            const ivBytes = Uint8Array.from(atob(group_key_iv), c => c.charCodeAt(0));

                            // Derive symmetric key using your ECDH private key and sender's public key
                            if (!recipientPublicKeys[sender]) {
                                let res = await fetch(`/get_public_key/${sender}`);
                                let pkData = await res.json();
                                if (pkData.public_key) {
                                    let importedKey = await crypto.subtle.importKey(
                                        "jwk",
                                        JSON.parse(pkData.public_key),
                                        { name: "ECDH", namedCurve: "P-256" },
                                        true,
                                        [] 
                                    );
                                    recipientPublicKeys[sender] = importedKey;
                                } else {
                                    console.error("Recipient public key not found for", sender);
                                    return;
                                }
                            }
                            const senderPubKey = recipientPublicKeys[sender];
                            const symmetricKey = await deriveSymmetricKey(userKeyPair.privateKey, senderPubKey);

                            const decryptedKeyBuffer = await crypto.subtle.decrypt(
                                { name: "AES-GCM", iv: ivBytes },
                                symmetricKey,
                                encryptedKeyBytes
                            );

                            const groupSymmetricKey = await crypto.subtle.importKey(
                                "raw",
                                decryptedKeyBuffer,
                                { name: "AES-GCM", length: 256 },
                                false,
                                ["encrypt", "decrypt"]
                            );

                            groupKeys[chatId] = groupSymmetricKey;
                            console.log("Group key imported and cached for", chatId);
                        }
                        try {
                            const plaintext = await decryptChatMessage(parsed.ciphertext, parsed.iv, groupKey);
                            showMessage(timestamp, sender, plaintext);
                        } catch (err) {
                            console.error("Failed to decrypt group message:", err);
                        }

                    } else {
                        // For general, display plaintext msgs.
                        showMessage(timestamp, sender, loggedMessage);
                    }
                } else {
                    console.warn("Log line did not split as expected:", log);
                }
            }
        }
        updateActiveChats();
    }




     //Displaying active chats for the user
    function updateActiveChats() {
        let activeChatsDiv = document.getElementById("active-chats");
        activeChatsDiv.innerHTML = Array.from(activeChats)
            .map(chat => { 
                let isActive = (chat === currentChatId);
                let btnClass = isActive ? 'chat-item-btn active-chat' : 'chat-item-btn';

                return `<button class="${btnClass}" onclick="loadChat('${chat}')">${chat}</button><br>`;
            })
            .join("");
    }



    //Displaying received message in our chat-box div
    const messages = document.getElementById("messages")
    const showMessage = (timstamp,sender,msg) => {
        const sanitizedMsg = DOMPurify.sanitize(msg);
        const texts = `
        <div class="text"> 
            <span>
                <strong>${sender}</strong>: ${sanitizedMsg}
            </span>
            <span>
                ${timstamp}
            </span>
        </div>
        `;
        messages.innerHTML += texts;
    };

    //Initializing Quill with text formatting for bold, italics, underline, lists, links, Emoji
    const quill = new Quill("#editor-container", {
        theme: "snow",
        placeholder: "Enter Message...",
        modules: {
            toolbar: [
                ["bold", "italic", "underline", "strike"],
                [{ 'header': 1 }, { 'header': 2 }],
                [{ 'script': 'sub'}, { 'script': 'super' }],
                [{ list: "ordered" }, { list: "bullet" }],
                [{ 'color': [] }, { 'background': [] }], // dropdown with defaults from theme
                ["link"],
                ["emoji"] //Adds emoji picker button
            ],
            "emoji-toolbar": true,
            "emoji-shortname": true
        }
    });

    async function sendMessage() {
    try {
        let message = quill.root.innerHTML.trim();
        if (!message || message === "<p><br></p>") return;
        let sanitizedMessage = DOMPurify.sanitize(message)
            .replace(/<\/p><p>/g, " ")
            .replace(/<p>|<\/p>/g, "")
            .replace(/<br>/g, " ");
        
        
        if (currentChatId !== "general_chat" && !currentChatId.startsWith("group_")) {
            // This branch is for one-to-one DM chats (encrypted)
            let participants = currentChatId.split("_");
            let recipient = participants.find(u => u !== username);
            if (!recipient) {
                console.error("Recipient not found in chat_id");
                return;
            }
            // Cache public key if not already cached.
            if (!recipientPublicKeys[recipient]) {
                let res = await fetch(`/get_public_key/${recipient}`);
                let pkData = await res.json();
                if (pkData.public_key) {
                    let jwk = JSON.parse(pkData.public_key);
                    let importedKey = await crypto.subtle.importKey(
                        "jwk",
                        jwk,
                        { name: "ECDH", namedCurve: "P-256" },
                        true,
                        []
                    );
                    recipientPublicKeys[recipient] = importedKey;
                } else {
                    console.error("Recipient public key not found for", recipient);
                    return;
                }
            }
            let conversationKey = await deriveSymmetricKey(userKeyPair.privateKey, recipientPublicKeys[recipient]);
            const { ciphertext, iv } = await encryptChatMessage(sanitizedMessage, conversationKey);
            let encodedCiphertext = btoa(String.fromCharCode(...ciphertext));
            let encodedIv = btoa(String.fromCharCode(...iv));
            console.log("Sending encrypted & sanitized message to WS Server:", encodedCiphertext);
            ws.send(JSON.stringify({
                chat_id: currentChatId,
                sender: username,
                message: encodedCiphertext,
                iv: encodedIv,
                encrypted: true
            }));
             // logs the encrypted DM to cockroachDB
            await logMessageToDb(
                currentChatId,
                "sent_encrypted",
                JSON.stringify({ ciphertext: encodedCiphertext, iv: encodedIv })
            );

            quill.root.innerHTML = "";

        } else if (currentChatId.startsWith("group_")) {
            //This branch handles group chats (encrypted) 
            let groupKey = groupKeys[currentChatId];
            if (!groupKey) {
                console.error("Group encryption key not available for", currentChatId);
                return;
            }

            const { ciphertext, iv } = await encryptChatMessage(sanitizedMessage, groupKey);
            let encodedCiphertext = btoa(String.fromCharCode(...ciphertext));
            let encodedIv = btoa(String.fromCharCode(...iv));

            ws.send(JSON.stringify({
                chat_id: currentChatId,
                sender: username,
                message: encodedCiphertext,
                iv: encodedIv,
                encrypted: true
            }));
                // logs the group encrypted DMs to cockroachDB
            await logMessageToDb(
                currentChatId,
                "sent_group_encrypted",
                JSON.stringify({ ciphertext: encodedCiphertext, iv: encodedIv })
            );
            quill.root.innerHTML = "";
        } else {
            // This branch handles general (unencrypted)
            ws.send(JSON.stringify({
                chat_id: currentChatId,
                sender: username,
                message: sanitizedMessage,
                encrypted: false
            }));

             // stores it in CockroachDB:
            await logMessageToDb(currentChatId, "sent", sanitizedMessage);

            quill.root.innerHTML = "";
        }

        
        } catch (outerError) {
            console.error("error sending message:", outerError);
        }
    }


    // Event listener to send message on 'Enter' key
    quill.root.addEventListener("keydown", function (event) {
        if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    });
    
    // Handler for Quill text-change events
    quill.on('text-change', function(delta, oldDelta, source) {
        console.log("Inside quill on")
        if (source === 'user') {
            sendTypingStatus(true);  // User started typing
            console.log("typing status set true")
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                sendTypingStatus(false);  // User stopped typing after 3 seconds idle
            }, 3000);
        }
    });

    // Send typing status over WebSocket
    function sendTypingStatus(isTyping) {
        if (ws && ws.readyState === WebSocket.OPEN && currentChatId) {
            ws.send(JSON.stringify({
                type: "typing",
                sender: username,
                isTyping: isTyping,
                chat_id: currentChatId
            }));
        }
    }

    // Show typing indicator in active chat
    function showTypingIndicator(user, isTyping) {
        const typingIndicator = document.getElementById("typing-indicator");

        if (isTyping) {
            let dots = "";
            typingIndicator.innerText = `${user} is typing`;
            typingIndicator.style.display = "block";
            
            clearInterval(typingAnimationInterval);  // Clear any previous intervals
            typingAnimationInterval = setInterval(() => {
                dots = dots.length < 3 ? dots + "." : "";
                typingIndicator.innerText = `${user} is typing${dots}`;
            }, 500); // update every 0.5 seconds

        } else {
            clearInterval(typingAnimationInterval);
            typingIndicator.innerText = "";
            typingIndicator.style.display = "none";
        }
    }

    //Handler for "Leave Room" button
    const leaveRoom = () => {
        firebase.auth().signOut()
        .then(() => {
            console.log("Firebase logged out");
            console.log("Leaving room...");
            ws.close();
            window.location.href = "/leave";  // Call backend after logout
        })
        .catch((error) => {
            console.error("Error signing out of Firebase:", error);
            // Still try to leave the room if Firebase logout fails
            console.log("Leaving room...");
            ws.close();
            window.location.href = "/leave";
        });
    };
</script>
{% endblock %}